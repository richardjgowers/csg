<tags>
  <item><name>cg.inverse.method</name><desc> ibi: inverse boltzmann imc: inverse monte carlo </desc></item>
  <item><name>cg.inverse.scriptpath</name><desc> list of directories for user scripts (e.g. $PWD) separated by a colon (like PATH)</desc></item>
  <item><name>cg.inverse.log_file</name><desc> write log to this file </desc></item>
  <item><name>cg.inverse.simulation</name><desc>simulation options </desc></item>
  <item><name>cg.inverse.simulation.tasks</name><desc>number of tasks (0/auto = automatic detect on linux)</desc></item>
  <item><name>cg.inverse.simulation.background</name><desc>tell csg_inverse that  simulation was send to the backgroud (default no)</desc></item>
  <item>
    <name>cg.inverse.restart_file</name>
    <desc>
      Name of the restart file in case a step has to be resumed
    </desc>
  </item>
  <item>
    <name>cg.inverse..gnuplot_bin</name>
    <desc>gnuplot binary to use (default gnuplot)</desc>
  </item>
  <item><name>cg.inverse.imc</name><desc> general imc specific options </desc></item>
  <item><name>cg.inverse.imc.solver</name><desc> solver for solving a linear equation system, can be octave or matlab </desc></item>
  <item><name>cg.inverse.imc.octave.bin</name><desc> Name (or absolute path) of the octave binary </desc></item>
  <item><name>cg.inverse.imc.numpy.bin</name><desc> Name (or absolute path) of the python binary used by the numpy solver</desc></item>
  <item><name>cg.inverse.imc.matlab.bin</name><desc> Name (or absolute path) of the matlab binary </desc></item>
  
  
  <!-- force matching stuff -->
  <item>
    <name>cg.fmatch</name>
    <desc>
      Force matching options
    </desc>
  </item>

  <item>
    <name>cg.fmatch.frames_per_block</name>
    <desc>
      number of frames, being used for block averaging. Atomistic trajectory, specified with
       --trj option, is divided into blocks and the force matching equations are solved separately for each block.
      Coarse-grained force-field, which one gets on the output is averaged over those blocks.
    </desc>
  </item>
    
  <item>
    <name>cg.fmatch.constrainedLS</name>
    <desc>
      boolean variable: false - simple least squares, true - constrained least squares.
      For details see the VOTCA paper. Practically, both algorithms give the same results,
      but simple least squares is faster. If you are a mathematician and you think that a spline
      can only then be called a spline if it has continuous first and second derivatives,
      use constrained least squares.
    </desc>
  </item>
</tags>
