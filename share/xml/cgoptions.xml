<tags>
  
  <item><name>cg</name><desc> Head option, which contains all coarse-graining options</desc></item>
  <item>
    <name>cg.non-bonded</name>
    <desc>
      Section for a non-bonded interaction. Most of the items in here are identical to items in cg.bonded,
      so they will be described in the same section.
    </desc>
  </item>
  <item>
    <name>cg.bonded</name>
    <desc>
      Section for a bonded interaction. Most of the items in here are identical to items in cg.bonded,
      so they will be described in the same section.
    </desc>
  </item>

<!-- general inverse options -->
  <item>
    <name>cg.inverse</name><section/>
    <desc>
      general options for inverse script
    </desc>
  </item>
  

  <item>
    <name>cg.inverse.cgmap</name>
    <desc>
      This option currently only has to be provided for IMC. It specifies the mapping file for
      analysis. Currently also during coarse-grained simulations, a mapping file has to be specified
      which is only a 1:1 mapping. This will change in the future.
    </desc>
  </item>
  <item><name>cg.inverse.kBT</name><desc> kBT (300*0.00831451 gromacs units) </desc></item>
  <item><name>cg.inverse.program</name><desc>simulation package to be used (currently only gromacs) </desc></item>

  <item><name>cg.inverse.$sim_prog</name><desc> generic simulation program (e.g. GROMACS) options </desc></item>
  <item><name>cg.inverse.$sim_prog.equi_time</name><default>0.0</default><desc> begin analysis after this time </desc></item>
  <item><name>cg.inverse.$sim_prog.first_frame</name><default>0</default><desc> trash so many frames at the beginning </desc></item>
  <item><name>cg.inverse.$sim_prog.topol</name><desc> topology + trajectory. Be careful, do not change yet! </desc></item>
  <item><name>cg.inverse.$sim_prog.traj</name><desc> topology + trajectory. Be careful, do not change yet! </desc></item>

  <item><name>cg.inverse.gromacs</name><desc> gromacs specific options </desc></item>
  <item><name>cg.inverse.gromacs.equi_time</name><default>0.0</default><desc> begin analysis after this time when using gromacs</desc></item>
  <item><name>cg.inverse.gromacs.first_frame</name><default>0</default><desc> trash so many frames at the beginning when using gromacs</desc></item>
  <item><name>cg.inverse.gromacs.topol</name><desc> Gromacs topology file to use, default topol.tpr</desc></item>
  <item><name>cg.inverse.gromacs.traj</name><desc> Gromacs trajectory fie to use, default traj.xtc</desc></item>
  <item><name>cg.inverse.gromacs.mpd</name><desc> Gromacs mdp fie to use, default grompp.mdp</desc></item>
  <item><name>cg.inverse.gromacs.grompp.index</name><desc> Gromacs grompp index file to use, default index.ndx</desc></item>
  <item><name>cg.inverse.gromacs.grompp.topol</name><desc> Gromacs grompp topol file to use, default topol.top</desc></item>
  <item><name>cg.inverse.gromacs.grompp.opts</name><desc> Additional options to Gromacs grompp (e.g. -maxwarn 1)</desc></item>
  <item><name>cg.inverse.gromacs.g_rdf.index</name><desc> Gromacs g_rdf index file to use, default index.ndx</desc></item>
  <item><name>cg.inverse.gromacs.g_rdf.topol</name><desc> Gromacs g_rdf topol file to use, default topol.tpr</desc></item>
  <item><name>cg.inverse.gromacs.g_rdf.opts</name><desc> Additional options to Gromacs g_rdf (e.g. -nopbc)</desc></item>
  <item><name>cg.inverse.gromacs.table_bins</name><desc> grid for table*.xvg !</desc></item>
  <item><name>cg.inverse.gromacs.pot_max</name><desc> cut the potential at this value (gromacs bug) </desc></item>
  <item><name>cg.inverse.gromacs.table_end</name><desc> extend the tables to this value </desc></item>
  <item><name>cg.inverse.gromacs.cufoff_check</name><desc> check interaction cutoffs against rvdw in mdp file: yes/no (default yes)</desc></item>
  <item><name>cg.inverse.filelist</name><desc> these files are copied for each new run </desc></item>
  <item><name>cg.inverse.cleanlist</name><desc> these files are removed after each new run </desc></item>
  <item><name>cg.inverse.iterations_max</name><desc> do so many iterations </desc></item>
  <item><name>cg.inverse.method</name><desc> ibm: inverse boltzmann imc: inverse monte carlo </desc></item>
  <item><name>cg.inverse.scriptdir</name><desc> directory for user scripts (e.g. $PWD)</desc></item>
  <item><name>cg.inverse.log_file</name><desc> write log to this file </desc></item>
  <item><name>cg.inverse.mpi</name><desc>mpi options </desc></item>
  <item><name>cg.inverse.mpi.tasks</name><desc>number of tasks </desc></item>
  <item><name>cg.inverse.mpi.cmd</name><desc>mpi command to run (e.g. mpirun -np 8)</desc></item>
  <item>
    <name>cg.inverse.restart_file</name>
    <desc>
      Name of the restart file in case a step has to be resumed
    </desc>
  </item>
  <item><name>cg.inverse.imc</name><desc> general imc specific options </desc></item>
  <item><name>cg.inverse.imc.solver</name><desc> solver to solve linear equation system, can be octave or matlab </desc></item>
  
  
  <!-- force matching stuff -->
  <item>
    <name>cg.fmatch</name>
    <desc>
      Force matching options
    </desc>
  </item>

  <item>
    <name>cg.fmatch.frames_per_block</name>
    <desc>
      number of frames, being used for block averaging. Atomistic trajectory, specified with
       --trj option, is divided into blocks and the force matching equations are solved separately for each block.
      Coarse-grained force-field, which one gets on the output is averaged over those blocks.
    </desc>
  </item>
    
  <item>
    <name>cg.fmatch.constrainedLS</name>
    <desc>
      boolean variable: false - simple least squares, true - constrained least squares.
      For details see VOTCA paper. Practically both algorithms give the same results,
      but simple least squares is faster. If you are mathematician and think that a spline
      is only then can be called spline if it has continuous first and second derivatives,
      use constrained least squares.
    </desc>
  </item>
</tags>
