<tags>
  <item><name>cg.inverse.gromacs.mdrun.command</name><desc>Command to run mdrun (name or absolute path or mpirun mdrun..)</desc></item>
  <item><name>cg.inverse.gromacs.mdrun.opts</name><desc> Additional options to Gromacs mdrun (e.g. -nosum)</desc></item>
  <item><name>cg.inverse.gromacs.mdrun.checkpoint</name><desc>Name of the checkpint to use in case of restarted simulation (default state.cpt)</desc></item>
  <item><name>cg.inverse.gromacs.g_energy.topol</name><desc> Gromacs g_energy topol file to use, default topol.tpr</desc></item>
  <item><name>cg.inverse.gromacs.g_energy.bin</name><desc> Name (or absolute path) of the g_energy binary</desc></item>
  <item><name>cg.inverse.gromacs.g_energy.opts</name><desc> Additional options to Gromacs g_energy (e.g. -P 1)</desc></item>
  <item><name>cg.inverse.gromacs.table_bins</name><desc> grid for table*.xvg !</desc></item>
  <item><name>cg.inverse.gromacs.pot_max</name><desc> cut the potential at this value (gromacs bug) </desc></item>
  <item><name>cg.inverse.gromacs.table_end</name><desc> extend the tables to this value </desc></item>
  <item><name>cg.inverse.gromacs.cutoff_check</name><desc> check interaction cutoffs against rvdw in mdp file: yes/no (default yes)</desc></item>
  <item><name>cg.inverse.gromacs.temp_check</name><desc> check temperture against t_ref in mdp file: yes/no (default yes)</desc></item>
  <item><name>cg.inverse.gromacs.rdf.topol</name><desc> Gromacs topol file to be used for csg_stat default topol.tpr</desc></item>
  <item><name>cg.inverse.gromacs.rdf.with_errors</name><desc> Also calculate error on the rdf</desc></item>
  <item><name>cg.inverse.gromacs.rdf.block_length</name><desc> Length of the block for the error analysis</desc></item>
  <item><name>cg.inverse.gromacs.density.with_errors</name><desc> Also calculate error on the density</desc></item>
  <item><name>cg.inverse.gromacs.density.block_length</name><desc> Length of the block for the error analysis</desc></item>
  <item><name>cg.inverse.espresso.blockfile</name><desc>Name of the original blockfile read by Espresso (default conf.esp.gz)</desc></item>
  <item><name>cg.inverse.espresso.blockfile_out</name><desc>Name of the original outcome blockfile written by Espresso (default confout.esp.gz)</desc></item>
  <item><name>cg.inverse.espresso.command</name><desc>Command to run espresso (name or absolute path or mpirun espresso..)</desc></item>
  <item><name>cg.inverse.espresso.rdf_command</name><desc>Espresso command to run when calculating the rdf (name or absolute path or mpirun espresso..)</desc></item>
  <item><name>cg.inverse.espresso.pressure_command</name><desc>Espresso command to run when calculating the pressure (name or absolute path or mpirun espresso..)</desc></item>
  <item><name>cg.inverse.espresso.first_frame</name><desc>rash the given number of frames at the beginning of trajectory</desc></item>
  <item><name>cg.inverse.espresso.table_bins</name><desc> grid for tabulated potentials </desc></item>
  <item><name>cg.inverse.espresso.traj</name><desc> Name of the output Espresso trajectory file</desc></item>
  <item><name>cg.inverse.espresso.n_steps</name><desc> number of steps to integrate before a snapshot</desc></item>
  <item><name>cg.inverse.espresso.n_snapshots</name><desc> number of snapshots. Total time = n_steps * n_snapshots</desc></item>
  <item><name>cg.inverse.espresso.debug</name><desc> debug Espresso (yes/no)</desc></item>
  <item><name>cg.inverse.espresso.table_end</name><desc> Espresso end of table</desc></item>
  <item><name>cg.inverse.espresso.exclusions</name><desc> Espresso stuff to exclude</desc></item>
  <item><name>cg.inverse.espresso.meta_cmd</name><desc> Espresso metadynamics command to call [experimental]</desc></item>
  <item><name>cg.inverse.espresso.success</name><desc> File to create if Espresso simulation was successfull</desc></item>
  <item><name>cg.inverse.espresso.meta_min_sampling</name><desc> Espresso metadynamics minimal number of sampling [experimental]</desc></item>
  <item><name>cg.inverse.espresso.scriptdir</name><desc>overwrite ESPRESSO_SCRIPTS from environment with this dir</desc></item>
  <item><name>cg.inverse.filelist</name><desc> these files are copied for each new run </desc></item>
  <item><name>cg.inverse.cleanlist</name><desc> these files are removed after each new run </desc></item>
  <item><name>cg.inverse.iterations_max</name><desc> do the given number of iterations (0=inf) </desc></item>
  <item><name>cg.inverse.convergence_check</name><desc>type of convergence check to do</desc></item>
  <item><name>cg.inverse.convergence_check_options</name><desc>options for the convergence check</desc></item>
  <item><name>cg.inverse.convergence_check_options.limit</name><desc>lower limit to stop</desc></item>
  <item><name>cg.inverse.convergence_check_options.name_glob</name><desc>files to check for number (default *.conv)</desc></item>
  <item><name>cg.inverse.method</name><desc> ibi: inverse boltzmann imc: inverse monte carlo </desc></item>
  <item><name>cg.inverse.scriptpath</name><desc> list of directories for user scripts (e.g. $PWD) separated by a colon (like PATH)</desc></item>
  <item><name>cg.inverse.log_file</name><desc> write log to this file </desc></item>
  <item><name>cg.inverse.simulation</name><desc>simulation options </desc></item>
  <item><name>cg.inverse.simulation.tasks</name><desc>number of tasks (0/auto = automatic detect on linux)</desc></item>
  <item><name>cg.inverse.simulation.background</name><desc>tell csg_inverse that  simulation was send to the backgroud (default no)</desc></item>
  <item>
    <name>cg.inverse.restart_file</name>
    <desc>
      Name of the restart file in case a step has to be resumed
    </desc>
  </item>
  <item>
    <name>cg.inverse..gnuplot_bin</name>
    <desc>gnuplot binary to use (default gnuplot)</desc>
  </item>
  <item><name>cg.inverse.imc</name><desc> general imc specific options </desc></item>
  <item><name>cg.inverse.imc.solver</name><desc> solver for solving a linear equation system, can be octave or matlab </desc></item>
  <item><name>cg.inverse.imc.octave.bin</name><desc> Name (or absolute path) of the octave binary </desc></item>
  <item><name>cg.inverse.imc.numpy.bin</name><desc> Name (or absolute path) of the python binary used by the numpy solver</desc></item>
  <item><name>cg.inverse.imc.matlab.bin</name><desc> Name (or absolute path) of the matlab binary </desc></item>
  
  
  <!-- force matching stuff -->
  <item>
    <name>cg.fmatch</name>
    <desc>
      Force matching options
    </desc>
  </item>

  <item>
    <name>cg.fmatch.frames_per_block</name>
    <desc>
      number of frames, being used for block averaging. Atomistic trajectory, specified with
       --trj option, is divided into blocks and the force matching equations are solved separately for each block.
      Coarse-grained force-field, which one gets on the output is averaged over those blocks.
    </desc>
  </item>
    
  <item>
    <name>cg.fmatch.constrainedLS</name>
    <desc>
      boolean variable: false - simple least squares, true - constrained least squares.
      For details see the VOTCA paper. Practically, both algorithms give the same results,
      but simple least squares is faster. If you are a mathematician and you think that a spline
      can only then be called a spline if it has continuous first and second derivatives,
      use constrained least squares.
    </desc>
  </item>
</tags>
